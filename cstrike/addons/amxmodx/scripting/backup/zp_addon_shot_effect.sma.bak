/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <engine>
#include <fakemeta_util>
#include <hamsandwich>

#define PLUGIN "New Plug-In"
#define VERSION "1.0"
#define AUTHOR "author"

new const GUNSHOT_DECALS[] = { 41, 42, 43, 44, 45 }

new const WeaponMuzzle[][]={
	"sprites/muzzleflash2.spr",
	"sprites/muzzleflash3.spr"
}

enum {
	DF_SMG,
	DF_RIFLE
}

enum {
	PISTOL,
	SHOTGUN,
	SMG,
	RIFLE,
	SNIPERRIFLE,
	MG,
	GRENADE
}

new cvar_color

#define MUZZLEFLASH_CLASSNAME "muzz1"

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	//register_think(MUZZLEFLASH_CLASSNAME, "fw_MuzzleFlash_Think") 	
	
	cvar_color = register_cvar("bullet_smoke_fun","0")
	//register_clcmd("say /bom","test")
}

public plugin_natives()
{
	register_native("navtive_bullet_effect","hit_wall_effect",1)
}
public plugin_precache()
{
	static i;
	for(i=0;i<sizeof(WeaponMuzzle);i++)
		precache_model(WeaponMuzzle[i])
}
public Show_Muzz(id)
{
	static weapon_type=0;
	switch (get_user_weapon(id))
	{
		case CSW_P228, CSW_ELITE, CSW_FIVESEVEN, CSW_USP, CSW_GLOCK18, CSW_DEAGLE:weapon_type=PISTOL;
		case CSW_M3, CSW_XM1014:
			weapon_type = SHOTGUN;
		case CSW_MAC10, CSW_TMP, CSW_MP5NAVY, CSW_UMP45, CSW_P90:
			weapon_type = SMG;
		case CSW_FAMAS, CSW_GALIL, CSW_AK47, CSW_M4A1, CSW_AUG, CSW_SG552:
			weapon_type = RIFLE;
		case CSW_SCOUT, CSW_AWP, CSW_SG550, CSW_G3SG1:
			weapon_type = SNIPERRIFLE;
		case CSW_M249:
			weapon_type = MG;
		case CSW_SMOKEGRENADE, CSW_HEGRENADE, CSW_FLASHBANG:
			weapon_type = GRENADE;
	}
	
	if(weapon_type ==PISTOL)
	{
		MakeMuzzleFlash(id, WeaponMuzzle[DF_SMG],random_float(0.0,1.0),0.15)
	}else if(weapon_type==SHOTGUN){
		MakeMuzzleFlash(id, WeaponMuzzle[DF_SMG],random_float(0.0,1.0),0.15)
	}else if(weapon_type==SMG){
		MakeMuzzleFlash(id, WeaponMuzzle[DF_SMG],random_float(0.0,1.0),0.15)
	}else if(weapon_type==RIFLE){
		MakeMuzzleFlash(id, WeaponMuzzle[DF_RIFLE],random_float(0.0,1.0),0.15)
	}else if(weapon_type==SNIPERRIFLE){
		MakeMuzzleFlash(id, WeaponMuzzle[DF_RIFLE],random_float(0.0,1.0),0.15)
	}else if(weapon_type==MG){
		MakeMuzzleFlash(id, WeaponMuzzle[DF_SMG],random_float(0.0,1.0),0.15)
	}
}

public remove_ent(ent)
{
	if(!pev_valid(ent))
		return;

	set_pev(ent, pev_flags, FL_KILLME)		
}

public hit_wall_effect(id, ent, ptr)
{
	if(get_user_weapon(id)==CSW_KNIFE)
		return;
	if(is_user_bot(id))
		return;
	//Show_Muzz(id)
	
	if(ent) return;
		
	//new Float:vecEnd[3], Float:vecPlane[3]
	new Float:vecSrc[3]
	get_tr2(ptr, TR_vecEndPos, vecSrc)
	//get_tr2(ptr, TR_vecPlaneNormal, vecEnd)
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_WORLDDECAL)
	engfunc(EngFunc_WriteCoord, vecSrc[0])
	engfunc(EngFunc_WriteCoord, vecSrc[1])
	engfunc(EngFunc_WriteCoord, vecSrc[2])
	write_byte(GUNSHOT_DECALS[random_num (0, sizeof GUNSHOT_DECALS -1)])
	message_end()
	
	// Show sparcles
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_GUNSHOTDECAL)
	engfunc(EngFunc_WriteCoord, vecSrc[0])
	engfunc(EngFunc_WriteCoord, vecSrc[1])
	engfunc(EngFunc_WriteCoord, vecSrc[2])
	write_short(id)
	write_byte(GUNSHOT_DECALS[random_num (0, sizeof GUNSHOT_DECALS -1)])
	message_end()	
	/*
	get_weapon_attachment(id, vecSrc)
	global_get(glb_v_forward, vecEnd)
    
	xs_vec_mul_scalar(vecEnd, 8192.0, vecEnd)
	xs_vec_add(vecSrc, vecEnd, vecEnd)
	
	message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
	write_byte(TE_STREAK_SPLASH)
	engfunc(EngFunc_WriteCoord, vecSrc[0])
	engfunc(EngFunc_WriteCoord, vecSrc[1])
	engfunc(EngFunc_WriteCoord, vecSrc[2])
	engfunc(EngFunc_WriteCoord, vecEnd[0] * random_float(25.0, 30.0))
	engfunc(EngFunc_WriteCoord, vecEnd[1] * random_float(25.0, 30.0))
	engfunc(EngFunc_WriteCoord, vecEnd[2] * random_float(25.0, 30.0))
	write_byte(get_pcvar_num(cvar_color)?random_num(0,100):43)
	//write_byte(43)
	write_short(30)
	write_short(2)
	write_short(90)    
	message_end()	    
	
	ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "env_sprite"))
	
	xs_vec_mul_scalar(vecEnd, 2.5, vecEnd)
	xs_vec_add(vecSrc, vecEnd, vecEnd)
	xs_vec_mul_scalar(vecPlane, 60.0, vecPlane);
	xs_vec_add(vecEnd, vecPlane, vecEnd);		
	
	entity_set_origin(ent, vecEnd)	
	entity_set_model(ent, "sprites/wall_puff1.spr")	
	entity_set_int(ent, EV_INT_solid, SOLID_NOT)
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_NOCLIP)	
	entity_set_float(ent, EV_FL_animtime, get_gametime())
	entity_set_float(ent, EV_FL_framerate, 50.0)       
	set_pev(ent, pev_scale, random_float(0.3, 0.6))		
	set_pev(ent, pev_spawnflags, SF_SPRITE_ONCE)
	set_pev(ent, pev_owner, id)
	
	// Set velocity
	new Float:vecVelocity[3], Float:vecRight[3], Float:vecUp[3];	
	engfunc(EngFunc_VecToAngles, vecPlane, vecPlane );	
	vector_to_angle(vecPlane, vecPlane);	
	angle_vector(vecPlane,ANGLEVECTOR_RIGHT,vecRight)
	angle_vector(vecPlane,ANGLEVECTOR_UP,vecUp)	
	vecVelocity[0] *= 32.0;
	vecVelocity[1] *= 32.0;
	vecVelocity[2] *= 32.0;	
	
	new Float:flRandomVec = random_float(0.0, 64.0) * random_float(-1.0, 1.0);	
	vecRight[0] *= flRandomVec;
	vecRight[1] *= flRandomVec;
	vecRight[2] *= flRandomVec;	
	flRandomVec = random_float(0.0, 64.0) * random_float(-1.0, 1.0);	
	vecUp[0] *= flRandomVec;
	vecUp[1] *= flRandomVec;
	vecUp[2] *= flRandomVec;	
	vecVelocity[0] += vecRight[0] + vecUp[0];
	vecVelocity[1] += vecRight[1] + vecUp[1];
	vecVelocity[2] += vecRight[2] + vecUp[2];
	
	set_pev(ent, pev_velocity, vecVelocity);
	
	DispatchSpawn(ent);	
	entity_set_int(ent, EV_INT_movetype, MOVETYPE_NOCLIP)	
	set_pev(ent, pev_rendermode,  kRenderTransAdd)	
	set_pev(ent, pev_renderamt,   60.0)	
	
	entity_set_float(ent, EV_FL_animtime, get_gametime())	
	entity_set_float(ent, EV_FL_nextthink, get_gametime() + 0.025);
	
	set_task(1.0,"remove_ent",ent)*/
}

stock get_weapon_attachment(id, Float:output[3], Float:fDis = 40.0)
{ 
	static Float:vfEnd[3], viEnd[3] 
	get_user_origin(id, viEnd, 3)  
	IVecFVec(viEnd, vfEnd) 
	
	static Float:fOrigin[3], Float:fAngle[3]
	
	pev(id, pev_origin, fOrigin) 
	pev(id, pev_view_ofs, fAngle)
	
	xs_vec_add(fOrigin, fAngle, fOrigin) 
	
	static Float:fAttack[3]
	
	xs_vec_sub(vfEnd, fOrigin, fAttack)
	xs_vec_sub(vfEnd, fOrigin, fAttack) 
	
	static Float:fRate
	
	fRate = fDis / vector_length(fAttack)
	xs_vec_mul_scalar(fAttack, fRate, fAttack)
	
	xs_vec_add(fOrigin, fAttack, output)
}

stock MakeMuzzleFlash(iPlayer, const muzz[]="sprites/muzzleflash2.spr", Float:startrate=0.0, Float:scale=0.2)
{
	
	static Ent;Ent = engfunc(EngFunc_CreateNamedEntity, engfunc(EngFunc_AllocString, "info_target"))	
	if(!pev_valid(Ent)) return
	
	set_pev(Ent, pev_classname, MUZZLEFLASH_CLASSNAME)
	
	set_pev(Ent, pev_owner, iPlayer)
	set_pev(Ent, pev_body, 1)
	set_pev(Ent, pev_skin, iPlayer)
	set_pev(Ent, pev_aiment, iPlayer)
	set_pev(Ent, pev_movetype, MOVETYPE_FOLLOW)
	
	set_pev(Ent, pev_scale, scale)
	set_pev(Ent, pev_frame, startrate)
	set_pev(Ent, pev_rendermode, kRenderTransAdd)
	set_pev(Ent, pev_renderamt, 200.0)
	
	engfunc(EngFunc_SetModel, Ent,  muzz)
	
	set_pev(Ent, pev_nextthink, get_gametime() + 0.04)
}

public fw_MuzzleFlash_Think(Ent)
{
	if(!pev_valid(Ent))
		return
	
	static Owner; Owner = pev(Ent, pev_owner)
	
	if(!is_user_alive(Owner))
	{
		set_pev(Ent, pev_flags, FL_KILLME)
		return
	}
	
	static iActiveItem; iActiveItem = get_pdata_cbase(Owner, 373, 5)
	
	if(!pev_valid(iActiveItem))
	{
		set_pev(Ent, pev_flags, FL_KILLME)
		return
	}

	static Float:Frame; pev(Ent, pev_frame, Frame)
	if(Frame > 4.0) 
	{
		set_pev(Ent, pev_flags, FL_KILLME)
		return
	}
	else
	{
		Frame += 1.0
		set_pev(Ent, pev_frame, Frame)
	}
	
	set_pev(Ent, pev_nextthink, get_gametime() + 0.04)
}
